* immediate

1. Work over log levels used in leader, candidate, follower, deck so that a clean but useful
   log output is made when selecting that level for those loggers.
2. update the message api elements to include a message serial number that is
   generated in raftengine cause it is hard for callers to keep track of what is happening.
   Do something like jan 1 2025 as base (1) * 100000 plus the number of days since then plus the seconds
   since midnight (max 86399, so max first day serial would be 186399, next day 286399) so timebase.
   Then multiply timebase * 1000000 (for a million msg per second)

#+BEGIN_SRC python
import time
from datetime import datetime, timezone

# Epoch: January 1, 2025, 00:00:00 UTC
EPOCH = datetime(2025, 1, 1, 0, 0, 0, tzinfo=timezone.utc).timestamp()

class SerialNumberGenerator:
    def __init__(self):
        self.last_timebase = None
        self.counter = 0

    def generate(self):
        # Get current UTC time
        now = time.time()
        # Calculate days and seconds since epoch
        seconds_since_epoch = int(now - EPOCH)
        days_since_epoch = seconds_since_epoch // 86400
        seconds_since_midnight = seconds_since_epoch % 86400
        # Compute timebase
        timebase = days_since_epoch * 86400 + seconds_since_midnight
        # Reset counter if timebase has changed
        if timebase != self.last_timebase:
            self.counter = 0
            self.last_timebase = timebase
        # Generate serial number
        serial = timebase * 1000000 + self.counter
        # Increment counter (up to 999,999)
        self.counter = (self.counter + 1) % 1000000
        return serial

# Example usage
generator = SerialNumberGenerator()
for _ in range(5):
    print(generator.generate())
    time.sleep(0.1)  # Simulate sending messages
#+END_SRC
  
   
* Test questions and issues and Demo issues

1. [X] Develop a plan for doing tracing in real processes, which means adding event callback support to the library.
   Maybe build an event dispatch dictionary so tracing points can be efficient. If there is a dict, then call
   a function that dispatches to traces, maybe passing locals() for context. That function can collect log data, message
   data, etc. Replace substate calls with this. Do the traces as JSON with class names in them so that it can
   be stored and reconstituted. Maybe make this an option, if the system works kind of like python logging, collection,
   filters, handlers, etc. Incorporate concerns below about error reporting. Maybe one event system for errors, and
   another just like it for non-errors so that they can be efficiently disabled.
   Earlier note with same intent:  Find all places where servers.py and tests open the white box and replace them with event
   generation and delivery to the pilot interface.
   1. An event class with an emum type
      1. Error
      2. Role Change
      3. Term Change
      4. Message In
	 1. some kind of filtering so that we can avoid eventing every message
      5. Message Out
	 1. some kind of filtering so that we can avoid eventing every message
      6. Message Summary (maybe publish and clear when heartbeat sent or received, or log index delta > threshold)
      7. Log Index Change
      8. Log Term Change
	 
	 
	 
 




