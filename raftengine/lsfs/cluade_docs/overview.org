

* Overall goal

Build a mechansim in python that uses the principles of log structered file systemms to
enable storage and retrieval of record oriented user data. Maximum write
performance is paramount and may be achieved at the cost of read performance
and of complexity.


1. Write of records to disk primarly through the use of direct IO features, with
   a fallback to ordinary file IO.
2. Support three types of records:
   1. Record streams, where the contents may be thought of as a log of events.
   2. Data streams, where the contents may be thought of as arbitrary portions of
      some larger data element such as raw file contents. Think downloading a zip
      file and pumping the downloaded chunks into a file. Only when complete does
      the data become and object.
   3. Final data, where the last record fully declares the contained state without
      regard to any previous records involving that state

** Notes:

+ Consider an out of process clerk process that assembles an index for the file
  that is structured to make reading faster. This would be useful for Raft since
  read from beginning is rare but should be fast when it happens so loading a node
   from scratch can be fast.
+ CRCs are not used because they provide little benefit when files are stored on
  most modern files systems. These typically have error detection and correction
  logic better than you can easily implement in user space. If your filesystem
  is lacking in these features, you might not want to uses this library.

    
** Record Stream Files
Terms:
| Block  | Fixed size outer container as written to disk, needed for direct IO                |
| Record | A wrapper around the user's serialized data, with header and tailer                |
| Slice  | A wrapper around all or some of a record, for fitting records into blocks          |

*** Block Structure
**** Header
| magic number | byte count |

**** Tailer
| magic number | byte count | last slice start |

*** Record Structure
**** Header
| magic number | record index |  user supplied type code, 64 bits |


**** Tailer
| magic number | record index  |  user supplied type code, 64 bits | first block number | first block offset |


*** Slice Structure
**** Header
| magic number | record index  | slice number |

**** Tailer
| magic number | record index  | slice number | block offset of start |

         
** Data Stream Files

Terms:
| Block | Fixed size outer container as written to disk, needed for direct IO                 |
| Mark  | A tailer on user's streamed data marking the semantic end of stream by user command |

Always come paired with a Final Data file that contains the block number and offset of the
tailer of the last Mark.

*** Block Structure
Same as that used for Record Streams
   
**** Header
| magic number | byte count |

**** Tailer
| magic number | byte count | last slice start |

*** Mark Structure
| magic number | byte count | first block number | first block offset | last block number |

** Final Data Files

Implemented as a pair of Record Stream files, where the incoming records flow to the "A" file
until a configured maximum number of blocks is reached whent the records begin to flow the "B"
file. Once the "B" file is full, the "A" file is truncated and records beging to flow there.

On reopen the file with the shortest non-zero length is taken to be the active file. Reading
is done by seeking to the end, collecting the 

