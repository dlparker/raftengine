Immediatly:



DONE 10. Leader should be tracking followers more formally, supposed to keep nextIndex and matchIndex

20. using **data in from_dict for messages instead of spelling it out

DONE    !!! Clean up LogRec, chaning "user_data" to command and result and add custom json serializer so
        that serialising the entries array just works

DONE    !!!  Change all the references to myPrevLogTerm etc, should be looking at
        the log data in the message to see what was sent. this is a reply problem at
	leader, needs to understant what the reply means. Should be either hearbeat (no entries)
	or it should be determinable from the log records orignally sent. 

DONE    !!!! Follower should look at log records when behind, and find not just a matching index,
         but matching term. So if the leader sends

	 last index 3 term 4
	 
	 and the follower has
	 
	 index 1 term 3
	 index 2 term 4
	 index 3 term 5

	 then the follower needs to send index 2 term 4. This will allow overwrite as speced.

23. See if message base_class has any value. Also study change to dataclasses

25. Add "caller_context" to command ops, pass it on process_command and return it
    in result. Maybe try one more time to make apply_command cleaner (and rename it
    while we are at it).
    
31. Update hull api, __init__ should not be in it, so some sort of set_config
    thing. Think about updating config while running. Maybe have some sort
    of feature in hull that holds any messages while reconfig runs?

33. Move log_api to api module

41. rough out ideas for cluster class
    1. Knows about "static config" provided at startup. Can be programatically changed?
    2. Knows about "dynamic config" resulting from cluster changes while running.
    3. teach candidate and leader to use it
    4. build quorum feature such that (if configed) there is a minimum dynamic cluster
       size for starting election, with default of 1/2 + 1 of static config. Prove this
       prevents the inconsistent values at same log index problem after partition heal
    9. Think about providing an optional uri map implementation for users.

50. Need PreVote and CheckQuorum: https://dev.to/tarantool/raft-notalmighty-how-to-make-it-more-robust-3a11

OOOOOOOPNEN
6. Think deep about reporting errors in raft code, and detecting them in testing. Break something
   such as rejected append entries and fiddle. Maybe can use substate stuff to alert to error
   and give pilot an api entry on hull to call to get errors?

11. Figure out how to log config changes, and in the process make general mechanism for
    non-command records.
    b. Add config read and write and config-to-and-from-json to hull. Think about defining
    and API for the hull (probably not since it needs stuff at init)


DONE!!!!!!7. !!!!! IMPORTANT !!!! change log api to be async

DONE! 8. fiddle with test logging to make it more helpful. different loggers for things, for example
       

DONE! 1. Messaege classes update
   a. Also remove leaderCommit from vote.
   b. Consider removing the data stuff from the messages too, it is not requred except for
      append entries sequences
   c. Look at each one for simplifications and clarifications. Build short and long __rep__
      for each

DONE! 2. Condense comms and DSL into a single structure, something like "pilot".

DONE 3. Make command call part of base state with appropriate response if not leader. Follower replies
   "redirect: uri", candiate response "retry". Build a test sequence for this.

DONE! 4. Build test wrapper (maybe an implementation of "pilot"?) that supports
   a. message pausing based on patterns, e.g. after sending an apppend entries response. DONE!
   b. Have it also know how to perform simulated timer triggers
      1. Figure out a clean way to manage call_later tasks from base state or from hull
         so that code looks sensible but supports manipulation during testing.
   c. Add support for firing breakpoint in on_message when condition met. Maybe subclass
      hull? Maybe monkey patch it? DONE!

DONE! 4W. Pull message transport code into simnet class, teach it to simulate partions.
    a. Keep granular api in current server and cluster that allows individual messages
       and the deliver_all_pending functions, along with the condition variable stuff


DONE! 5. Need timeout mechanism for command (timeout supplied to condition.wait)

   
DONE 6. fix the asyncio fixture setting problem in tests, have to update the re-election tests


